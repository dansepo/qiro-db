# QIRO 코딩 컨벤션

## 1. 문서 정보
- **문서명:** QIRO 코딩 컨벤션
- **프로젝트명:** QIRO (중소형 건물관리 SaaS) 프로젝트
- **작성일:** 2025년 05월 28일
- **최종 수정일:** 2025년 05월 28일
- **작성자:** (이름 또는 개발팀 리드)
- **검토자/승인자 (선택 사항):** (이름 또는 팀)
- **문서 버전:** 1.0

## 2. 개요
### 2.1. 문서 목적
본 문서는 QIRO 프로젝트 개발 과정에서 작성되는 모든 소스 코드의 스타일, 형식, 명명 규칙 등을 통일하여 코드의 가독성, 일관성, 유지보수성을 향상시키는 것을 목적으로 한다. 모든 개발자는 본 컨벤션을 숙지하고 준수해야 한다.

### 2.2. 적용 범위
본 컨벤션은 QIRO 프로젝트의 모든 소스 코드, 포함하여 백엔드(Kotlin, Spring Boot), 프론트엔드(TypeScript, Next.js, React), 기타 스크립트 및 설정 파일에 적용된다.

### 2.3. 기본 원칙
- **가독성 (Readability):** 코드는 사람이 이해하기 쉽게 작성한다.
- **단순성 (Simplicity):** 불필요하게 복잡한 코드는 지양하고, 간결하고 명확하게 작성한다.
- **일관성 (Consistency):** 프로젝트 전체에 걸쳐 일관된 스타일과 규칙을 적용한다.
- **예측 가능성 (Predictability):** 다른 개발자가 코드를 쉽게 예측하고 이해할 수 있도록 작성한다.
- **팀 협업 (Collaboration):** 팀 전체의 생산성 향상을 위해 정해진 규칙을 따른다.

### 2.4. 준수 방법
- **코드 리뷰:** 모든 코드는 Pull Request(PR) 또는 Merge Request(MR) 시 동료 개발자의 리뷰를 거치며, 본 컨벤션 준수 여부를 확인한다.
- **정적 분석 도구 활용:** Linter 및 Formatter(아래 '7. 정적 분석 도구' 항목 참조)를 사용하여 코드 스타일을 자동으로 검사하고 교정한다. CI 과정에 Linter 검사를 포함한다.

## 3. 공통 컨벤션
### 3.1. 네이밍 컨벤션 (Naming Conventions)
- **일반 원칙:**
    - 의미가 명확하고 발음하기 쉬운 영문 이름을 사용한다.
    - 축약어 사용은 지양하되, 널리 통용되는 축약어(예: `Id`, `DTO`, `URL`)는 허용한다.
    - 팀 내에서 용어 사전을 정의하고 일관되게 사용한다. (예: `Building` vs `Property`)
- **언어별 상세 규칙은 각 언어 섹션 참조.**

### 3.2. 포맷팅 (Formatting)
- **들여쓰기 (Indentation):**
    - Kotlin: 4 스페이스
    - TypeScript/JavaScript/JSON/CSS/HTML: 2 스페이스
- **최대 줄 길이 (Max Line Length):** 120자 권장. (Linter/Formatter 설정 따름)
- **중괄호 스타일 (Brace Style):** 각 언어의 표준 스타일 또는 Linter/Formatter 기본 설정을 따른다.
- **공백 (Whitespace):** 연산자, 쉼표, 콜론 주변 등 가독성을 해치지 않는 범위에서 일관되게 사용한다. (Linter/Formatter 설정 따름)
- **자동 포맷터 사용 필수:** 각 언어별로 지정된 Formatter를 사용하여 커밋 전 코드를 자동 정렬한다.

### 3.3. 주석 (Comments)
- **목적:** 코드가 "어떻게" 동작하는지보다는 "왜" 그렇게 작성되었는지, 또는 복잡한 로직의 의도를 설명하는 데 중점을 둔다.
- **스타일:**
    - Kotlin: KDoc (`/** ... */`)을 사용하여 API 및 주요 클래스/함수 설명. 일반 주석은 `//` 또는 `/* ... */`.
    - TypeScript/JavaScript: JSDoc/TSDoc (`/** ... */`)을 사용하여 API, 함수, 컴포넌트 props 설명. 일반 주석은 `//` 또는 `/* ... */`.
- **지양해야 할 주석:**
    - 코드를 그대로 반복하는 주석.
    - 주석 처리된 코드 블록 (필요 없는 코드는 삭제, Git 이력으로 관리).
    - 변경된 코드와 동기화되지 않은 오래된 주석.
- **TODO 주석:** `// TODO: [설명] - [작성자] [날짜]` 형식으로 작성하고, 정기적으로 검토하여 처리한다.

### 3.4. 에러 처리 (Error Handling)
- 예상 가능한 오류는 명시적으로 처리한다 (예: `try-catch`, `Result` 타입, `Either` 타입).
- 오류 메시지는 사용자 친화적이거나(클라이언트), 문제 해결에 도움이 되는 상세 정보(서버 로그)를 포함해야 한다.
- 커스텀 예외 클래스는 의미가 명확하도록 정의하고, 상속 구조를 적절히 활용한다.

### 3.5. 로깅 (Logging)
- **로그 레벨 사용 기준:**
    - `ERROR`: 즉각적인 조치가 필요한 심각한 오류.
    - `WARN`: 잠재적인 문제 또는 비정상적이지만 시스템 중단을 유발하지 않는 상황.
    - `INFO`: 주요 처리 과정 및 상태 변경 등 일반적인 정보.
    - `DEBUG`: 개발 및 디버깅 단계에서만 필요한 상세 정보. (운영 환경에서는 기본적으로 비활성화)
    - `TRACE`: DEBUG보다 더 상세한 정보.
- **로그 형식:** 타임스탬프, 로그 레벨, 스레드 ID(백엔드), 클래스/메소드명, 메시지를 포함하는 일관된 형식 사용. (Logback/Log4j2 설정 따름)
- **민감 정보 로깅 금지:** 비밀번호, 개인 식별 정보, API 키 등 민감한 정보는 로그에 기록하지 않는다.

## 4. 백엔드 코딩 컨벤션 (Kotlin & Spring Boot)
### 4.1. Kotlin 공식 코딩 컨벤션
- JetBrains에서 제공하는 [Kotlin Coding Conventions](https://kotlinlang.org/docs/coding-conventions.html)를 최우선으로 준수한다.
- IntelliJ IDEA의 Kotlin Formatter 기본 설정을 따른다.

### 4.2. 네이밍
- **패키지 (Packages):** 소문자, `.`으로 구분. (예: `com.qiro.building.service`)
- **클래스 및 인터페이스 (Classes & Interfaces):** `PascalCase`. (예: `BuildingService`, `TenantRepository`)
- **함수 및 프로퍼티 (Functions & Properties):** `camelCase`. (예: `getBuildingDetails`, `buildingAddress`)
- **상수 (Constants - `const val`, `object` 내 `val`):** `UPPER_SNAKE_CASE`. (예: `MAX_RETRY_COUNT`)
- **테스트 함수:** `given_유스케이스_when_조건_then_결과` 또는 `대상메소드_테스트조건_예상결과` 형식 권장. (예: `getBuildingById_whenIdExists_thenReturnsBuildingDto`)

### 4.3. 코드 스타일
- **불변성 (Immutability):** `val` 사용을 기본으로 하고, 변경 가능한 상태는 최소화한다. `data class`와 불변 컬렉션(`listOf`, `mapOf`, `setOf`)을 적극 활용한다.
- **Null 안전성 (Null Safety):** Kotlin의 Null Safety 기능을 적극 활용한다 (`?`, `!!.`, `?:`, `let`, `run` 등). `!!` 연산자 사용은 최대한 지양하고, 안전한 호출이나 Elvis 연산자로 대체한다.
- **타입 추론 (Type Inference):** 명확성이 저해되지 않는 범위 내에서 지역 변수 타입 추론을 활용한다. API 경계(함수 파라미터, 반환 타입)에서는 명시적 타입 선언을 권장한다.
- **확장 함수 (Extension Functions):** 가독성을 높이고 재사용성을 증진시키는 경우 적절히 활용한다.
- **스코프 함수 (Scope Functions - `let`, `run`, `with`, `apply`, `also`):** 명확하고 간결한 코드 작성을 위해 적절히 사용하되, 과도하거나 중첩된 사용은 지양한다.
- **람다 표현식 (Lambda Expressions):** 간결하게 작성하고, 파라미터가 하나인 경우 `it` 사용을 고려한다.

### 4.4. Spring Boot 관련
- **어노테이션:** 가독성을 위해 적절히 그룹화하고, 필요한 최소한의 어노테이션을 사용한다.
- **DTO (Data Transfer Object):** `data class`를 사용하고, Request/Response DTO는 명확히 구분한다. (예: `CreateBuildingRequest`, `BuildingResponse`)
- **레이어 구분:** Controller - Service - Repository 간의 역할과 책임을 명확히 구분한다.
- **의존성 주입:** 생성자 주입(Constructor Injection)을 기본으로 사용한다.
- **트랜잭션 관리:** `@Transactional` 어노테이션은 Service 레이어의 Public 메소드에 적용하는 것을 원칙으로 한다. `readOnly = true` 옵션을 적절히 활용한다.

## 5. 프론트엔드 코딩 컨벤션 (Next.js & TypeScript)
### 5.1. TypeScript 스타일 가이드
- Airbnb JavaScript Style Guide 또는 Google TypeScript Style Guide 등을 참고하여 팀 내 스타일 가이드 확립. (ESLint, Prettier 설정으로 강제)
- TypeScript의 정적 타입 기능을 최대한 활용하여 타입 안정성을 높인다. (`any` 타입 사용 최소화)

### 5.2. 네이밍
- **파일 (Files):** 컴포넌트 파일은 `PascalCase.tsx` (예: `BuildingCard.tsx`). 일반 모듈/훅 파일은 `camelCase.ts` 또는 `kebab-case.ts` (예: `useBuildingForm.ts`, `api-client.ts`). (팀 내 통일)
- **컴포넌트 (Components):** `PascalCase`. (예: `BuildingList`, `LoginForm`)
- **변수 및 함수 (Variables & Functions):** `camelCase`. (예: `buildingData`, `fetchBuildingDetails`)
- **상수 (Constants):** `UPPER_SNAKE_CASE` 또는 `PascalCase` (Readonly 객체). (예: `API_BASE_URL`, `DefaultUserSettings`)
- **타입 및 인터페이스 (Types & Interfaces):** `PascalCase`. (예: `Building`, `IUser`)

### 5.3. 코드 스타일 (React/Next.js)
- **함수형 컴포넌트와 Hooks 사용:** 클래스형 컴포넌트보다는 함수형 컴포넌트와 Hooks 사용을 기본으로 한다.
- **컴포넌트 구조:** 가독성을 위해 컴포넌트는 논리적인 단위로 분리하고, 파일 크기를 적절히 유지한다. (예: Presentational/Container 컴포넌트 패턴, Atomic Design 패턴 참고)
- **Props:**
    - `interface` 또는 `type`을 사용하여 Props 타입을 명확히 정의한다.
    - Props는 최대한 불변으로 다룬다.
    - Props Drilling을 피하기 위해 Context API, 상태 관리 라이브러리 등을 적절히 활용한다.
- **상태 관리:** (선택한 상태 관리 라이브러리 - Zustand, Recoil, Redux Toolkit 등 - 의 Best Practice 준수)
- **스타일링:** (선택한 스타일링 방식 - Tailwind CSS, Styled-components, Emotion, CSS Modules - 의 컨벤션 준수)
- **비동기 처리:** `async/await` 사용을 기본으로 하고, Promise 에러 처리를 명확히 한다.

### 5.4. 디렉토리 구조 (예시)
```
/src
  /app                 # Next.js App Router (또는 /pages)
  /components          # 재사용 가능한 UI 컴포넌트
    /common            # 범용 컴포넌트 (Button, Input 등)
    /domain            # 특정 도메인 관련 컴포넌트 (BuildingCard, FeeCalculator 등)
  /hooks               # 커스텀 React Hooks
  /lib                 # API 클라이언트, 유틸리티 함수 등
  /store               # 상태 관리 (Zustand, Recoil 등)
  /styles              # 전역 스타일, 테마
  /types               # 공통 타입 정의
  /utils               # 범용 유틸리티 함수
```
(팀의 디렉토리 구조 표준을 정의하고 따름)

## 6. Git 사용 컨벤션
### 6.1. 브랜치 전략
- (예: Git Flow - `main`, `develop`, `feature/이슈번호-기능요약`, `release/버전`, `hotfix/이슈번호-수정요약`)
- 브랜치명은 소문자, `kebab-case` 사용.

### 6.2. 커밋 메시지 컨벤션
- **Conventional Commits** 형식 준수 권장: ([https://www.conventionalcommits.org/](https://www.conventionalcommits.org/))
    - 형식: `<type>(<scope>): <subject>`
    - `<type>`: `feat` (기능), `fix` (버그 수정), `docs` (문서), `style` (포맷팅), `refactor`, `test`, `chore` (빌드 등)
    - `<scope>` (선택 사항): 변경 범위 (예: `building`, `auth`)
    - `<subject>`: 현재 시제, 명령문으로 간결하게 작성. 첫 글자 대문자 X, 마침표 X.
    - (본문 및 푸터는 필요시 작성)
- 예: `feat(building): Add new building registration form`
- 예: `fix(auth): Correct token expiration issue`
- 커밋 메시지는 **영문 작성**을 기본으로 한다. (팀 합의에 따라 한글도 가능하나, 일관성 유지)

### 6.3. Pull Request (PR) / Merge Request (MR)
- PR 제목은 커밋 메시지 컨벤션을 따르거나, 변경 내용을 명확히 요약한다.
- PR 본문에는 변경 목적, 주요 내용, 테스트 방법, 관련 이슈 번호 등을 상세히 기술한다. (PR 템플릿 활용)
- 최소 1명 이상의 동료 개발자로부터 코드 리뷰 승인(Approve)을 받아야 머지 가능.
- CI 빌드 및 테스트 통과 필수.
- 머지 전 자신의 브랜치를 최신 `develop` (또는 대상 브랜치) 기준으로 Rebase 하는 것을 권장.

## 7. 정적 분석 도구 설정 및 사용
### 7.1. 백엔드 (Kotlin)
- **Linter/Formatter:** **ktlint**
    - Gradle 플러그인 설정 (`build.gradle.kts`):
      ```kotlin
      // 예시
      plugins {
          id("org.jlleitschuh.gradle.ktlint") version "11.x.x" // 최신 버전 확인
      }
      ktlint {
          version.set("0.49.1") // 사용할 ktlint 버전
          // 추가 설정
      }
      ```
    - 실행: `./gradlew ktlintCheck` (검사), `./gradlew ktlintFormat` (자동 수정)
    - IntelliJ IDEA ktlint 플러그인 설치 및 IDE Formatter와 연동 권장.

### 7.2. 프론트엔드 (TypeScript/Next.js)
- **Linter:** **ESLint** (with `@typescript-eslint/parser`, `eslint-plugin-react`, `eslint-plugin-react-hooks`, `eslint-plugin-jsx-a11y`, `eslint-plugin-next`)
- **Formatter:** **Prettier**
- 프로젝트 루트에 `.eslintrc.js` (또는 `.json`), `.prettierrc.js` (또는 `.json`) 설정 파일 공유.
- VS Code 등 IDE에서 ESLint, Prettier 확장 프로그램 설치 및 "Format on Save" 설정 권장.
- `package.json` scripts에 lint 및 format 명령어 추가:
  ```json
  "scripts": {
    "lint": "eslint . --ext .ts,.tsx",
    "lint:fix": "eslint . --ext .ts,.tsx --fix",
    "format": "prettier --write \"**/*.{ts,tsx,js,jsx,json,md}\""
  }
  ```

## 8. (선택) 코드 리뷰 가이드라인
- **리뷰어:**
    - 컨벤션 준수 여부, 로직 오류, 잠재적 버그, 성능/보안 이슈, 가독성, 테스트 커버리지 등을 확인.
    - 비판보다는 건설적인 피드백 제공. 질문을 통해 의도 파악. 대안 제시.
- **리뷰 요청자 (작성자):**
    - PR 생성 전 자체적으로 충분히 테스트하고 컨벤션 점검.
    - PR 설명에 변경 사항의 목적과 내용을 명확히 기술.
    - 리뷰어의 피드백을 존중하고 적극적으로 소통.

## 9. 부록 (선택 사항)
- (프로젝트 관련 약어 및 용어 정의)
- (참고할 만한 외부 코딩 스타일 가이드 링크)

## 10. 문서 이력
| 버전 | 날짜          | 작성자 | 주요 변경 내용      |
| :--- | :------------ | :----- | :------------------ |
| 1.0  | 2025-05-28    | (이름)  | QIRO 코딩 컨벤션 초안 작성 |
|      |               |        |                     |

---